"use strict";(globalThis.webpackChunkmochaapi_client_docs=globalThis.webpackChunkmochaapi_client_docs||[]).push([[305],{3968:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"advanced-features","title":"Advanced Features","description":"Learn about MochaJSON v1.1.0 advanced features including ApiClient, interceptors, virtual threads, and security enhancements.","source":"@site/docs/advanced-features.md","sourceDirName":".","slug":"/advanced-features","permalink":"/MochaJSON/advanced-features","draft":false,"unlisted":false,"editUrl":"https://github.com/guptavishal-xm1/MochaJSON/tree/main/docs/docs/advanced-features.md","tags":[],"version":"current","frontMatter":{"title":"Advanced Features","description":"Learn about MochaJSON v1.1.0 advanced features including ApiClient, interceptors, virtual threads, and security enhancements."},"sidebar":"tutorialSidebar","previous":{"title":"Error Handling Examples","permalink":"/MochaJSON/usage/error-handling-examples"},"next":{"title":"Interceptors","permalink":"/MochaJSON/advanced/interceptors"}}');var i=t(4848),o=t(8453);const s={title:"Advanced Features",description:"Learn about MochaJSON v1.1.0 advanced features including ApiClient, interceptors, virtual threads, and security enhancements."},a="Advanced Features",l={},c=[{value:"ApiClient with Builder Pattern",id:"apiclient-with-builder-pattern",level:2},{value:"Basic Configuration",id:"basic-configuration",level:3},{value:"Custom Executor",id:"custom-executor",level:3},{value:"Request and Response Interceptors",id:"request-and-response-interceptors",level:2},{value:"Request Interceptors",id:"request-interceptors",level:3},{value:"Response Interceptors",id:"response-interceptors",level:3},{value:"Enhanced Async Operations",id:"enhanced-async-operations",level:2},{value:"CompletableFuture API",id:"completablefuture-api",level:3},{value:"Multiple Concurrent Requests",id:"multiple-concurrent-requests",level:3},{value:"Async with Callbacks",id:"async-with-callbacks",level:3},{value:"Virtual Threads Support",id:"virtual-threads-support",level:2},{value:"Automatic Virtual Threads",id:"automatic-virtual-threads",level:3},{value:"Fallback for Older Java Versions",id:"fallback-for-older-java-versions",level:3},{value:"Security Features",id:"security-features",level:2},{value:"URL Validation",id:"url-validation",level:3},{value:"Hardened JSON Parsing",id:"hardened-json-parsing",level:3},{value:"Timeout Protection",id:"timeout-protection",level:3},{value:"Logging Support",id:"logging-support",level:2},{value:"Basic Logging",id:"basic-logging",level:3},{value:"Custom Logging",id:"custom-logging",level:3},{value:"SLF4J Integration",id:"slf4j-integration",level:3},{value:"Migration from v1.0.x",id:"migration-from-v10x",level:2},{value:"Existing Code Continues to Work",id:"existing-code-continues-to-work",level:3},{value:"Optional Migration to ApiClient",id:"optional-migration-to-apiclient",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Use ApiClient for Production",id:"use-apiclient-for-production",level:3},{value:"Handle Async Operations Properly",id:"handle-async-operations-properly",level:3},{value:"Use Interceptors for Cross-Cutting Concerns",id:"use-interceptors-for-cross-cutting-concerns",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Virtual Threads",id:"virtual-threads",level:3},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Memory Usage",id:"memory-usage",level:3}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"advanced-features",children:"Advanced Features"})}),"\n",(0,i.jsx)(n.p,{children:"MochaJSON v1.1.0 introduces powerful new features for enterprise-grade applications. This guide covers the advanced capabilities that make MochaJSON suitable for production environments."}),"\n",(0,i.jsx)(n.h2,{id:"apiclient-with-builder-pattern",children:"ApiClient with Builder Pattern"}),"\n",(0,i.jsxs)(n.p,{children:["The new ",(0,i.jsx)(n.code,{children:"ApiClient"})," class provides advanced configuration options through a fluent builder pattern."]}),"\n",(0,i.jsx)(n.h3,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import io.mochaapi.client.*;\nimport java.time.Duration;\n\n// Create a configured client\nApiClient client = new ApiClient.Builder()\n    .connectTimeout(Duration.ofSeconds(10))\n    .readTimeout(Duration.ofSeconds(30))\n    .writeTimeout(Duration.ofSeconds(15))\n    .build();\n\n// Use the client for requests\nApiResponse response = client.get("https://api.example.com/data")\n    .query("page", 1)\n    .execute();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"custom-executor",children:"Custom Executor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"import java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\n\n// Use a custom executor for async operations\nExecutor customExecutor = Executors.newFixedThreadPool(10);\nApiClient client = new ApiClient.Builder()\n    .executor(customExecutor)\n    .build();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"request-and-response-interceptors",children:"Request and Response Interceptors"}),"\n",(0,i.jsx)(n.p,{children:"Interceptors allow you to modify requests and responses, add logging, authentication, and more."}),"\n",(0,i.jsx)(n.h3,{id:"request-interceptors",children:"Request Interceptors"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Authentication interceptor\nRequestInterceptor authInterceptor = RequestInterceptor.bearerAuth(() -> getToken());\n\n// Logging interceptor\nRequestInterceptor loggingInterceptor = RequestInterceptor.logging(System.out::println);\n\n// Custom headers interceptor\nMap<String, String> headers = Map.of(\n    "X-API-Version", "v1.1.0",\n    "X-Client-Type", "mobile"\n);\nRequestInterceptor headerInterceptor = RequestInterceptor.addHeaders(headers);\n\n// Custom interceptor\nRequestInterceptor customInterceptor = request -> {\n    System.out.println("Sending request to: " + request.getUrl());\n    return request.header("X-Request-ID", UUID.randomUUID().toString());\n};\n\nApiClient client = new ApiClient.Builder()\n    .addRequestInterceptor(authInterceptor)\n    .addRequestInterceptor(loggingInterceptor)\n    .addRequestInterceptor(headerInterceptor)\n    .addRequestInterceptor(customInterceptor)\n    .build();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"response-interceptors",children:"Response Interceptors"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Logging interceptor\nResponseInterceptor loggingInterceptor = ResponseInterceptor.logging(System.out::println);\n\n// Error handling interceptor\nResponseInterceptor errorInterceptor = ResponseInterceptor.throwOnError();\n\n// Retry interceptor\nint[] retryableCodes = {500, 502, 503, 504};\nResponseInterceptor retryInterceptor = ResponseInterceptor.retryOnStatus(retryableCodes, 3);\n\n// Custom interceptor\nResponseInterceptor customInterceptor = response -> {\n    if (response.code() >= 400) {\n        System.err.println("Error response: " + response.code() + " - " + response.body());\n    }\n    return response;\n};\n\nApiClient client = new ApiClient.Builder()\n    .addResponseInterceptor(loggingInterceptor)\n    .addResponseInterceptor(errorInterceptor)\n    .addResponseInterceptor(retryInterceptor)\n    .addResponseInterceptor(customInterceptor)\n    .build();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"enhanced-async-operations",children:"Enhanced Async Operations"}),"\n",(0,i.jsx)(n.p,{children:"MochaJSON v1.1.0 provides modern async APIs with virtual threads support."}),"\n",(0,i.jsx)(n.h3,{id:"completablefuture-api",children:"CompletableFuture API"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import java.util.concurrent.CompletableFuture;\n\nApiClient client = new ApiClient.Builder().build();\n\n// Basic async request\nCompletableFuture<ApiResponse> future = client.get("https://api.example.com/data")\n    .executeAsync();\n\n// Handle the response\nfuture.thenAccept(response -> {\n    System.out.println("Response: " + response.code());\n    Map<String, Object> data = response.toMap();\n    System.out.println("Data: " + data);\n});\n\n// Chain operations\nCompletableFuture<String> chainedFuture = client.get("https://api.example.com/user")\n    .executeAsync()\n    .thenApply(response -> {\n        Map<String, Object> user = response.toMap();\n        return user.get("name").toString();\n    })\n    .thenApply(name -> {\n        System.out.println("Processing user: " + name);\n        return name.toUpperCase();\n    });\n\nString result = chainedFuture.get();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"multiple-concurrent-requests",children:"Multiple Concurrent Requests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Start multiple requests concurrently\nCompletableFuture<ApiResponse> userFuture = client.get("https://api.example.com/user").executeAsync();\nCompletableFuture<ApiResponse> postsFuture = client.get("https://api.example.com/posts").executeAsync();\nCompletableFuture<ApiResponse> commentsFuture = client.get("https://api.example.com/comments").executeAsync();\n\n// Wait for all to complete\nCompletableFuture<Void> allFutures = CompletableFuture.allOf(userFuture, postsFuture, commentsFuture);\nallFutures.get();\n\n// Process results\nApiResponse userResponse = userFuture.get();\nApiResponse postsResponse = postsFuture.get();\nApiResponse commentsResponse = commentsFuture.get();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"async-with-callbacks",children:"Async with Callbacks"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Using callbacks (backward compatible)\nclient.get("https://api.example.com/data")\n    .async(response -> {\n        System.out.println("Async response: " + response.code());\n        // Process response...\n    });\n'})}),"\n",(0,i.jsx)(n.h2,{id:"virtual-threads-support",children:"Virtual Threads Support"}),"\n",(0,i.jsx)(n.p,{children:"MochaJSON automatically uses virtual threads when running on Java 21+, providing better performance for concurrent operations."}),"\n",(0,i.jsx)(n.h3,{id:"automatic-virtual-threads",children:"Automatic Virtual Threads"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Virtual threads are used automatically on Java 21+\nApiClient client = new ApiClient.Builder().build();\n\n// These requests will use virtual threads for better performance\nfor (int i = 0; i < 1000; i++) {\n    client.get("https://api.example.com/data/" + i)\n        .executeAsync()\n        .thenAccept(response -> {\n            // Process response...\n        });\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"fallback-for-older-java-versions",children:"Fallback for Older Java Versions"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// On Java 17 or earlier, MochaJSON automatically falls back to cached thread pool\n// No code changes required - it's handled transparently\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-features",children:"Security Features"}),"\n",(0,i.jsx)(n.p,{children:"MochaJSON v1.1.0 includes comprehensive security enhancements."}),"\n",(0,i.jsx)(n.h3,{id:"url-validation",children:"URL Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Valid URLs are accepted\nclient.get("https://api.example.com/data").execute(); // \u2705 OK\nclient.get("http://api.example.com/data").execute();  // \u2705 OK\n\n// Dangerous URLs are rejected\ntry {\n    client.get("javascript:alert(\'xss\')").execute(); // \u274c IllegalArgumentException\n} catch (IllegalArgumentException e) {\n    System.out.println("Dangerous URL rejected: " + e.getMessage());\n}\n\ntry {\n    client.get("file:///etc/passwd").execute(); // \u274c IllegalArgumentException\n} catch (IllegalArgumentException e) {\n    System.out.println("File URL rejected: " + e.getMessage());\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"hardened-json-parsing",children:"Hardened JSON Parsing"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// JSON parsing is automatically hardened against common attacks\n// - Polymorphic typing is disabled\n// - Dangerous features are turned off\n// - Input validation is enhanced\n\nApiResponse response = client.get("https://api.example.com/data").execute();\nMap<String, Object> data = response.toMap(); // Safe parsing\n'})}),"\n",(0,i.jsx)(n.h3,{id:"timeout-protection",children:"Timeout Protection"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Configure timeouts to prevent resource exhaustion\nApiClient client = new ApiClient.Builder()\n    .connectTimeout(Duration.ofMillis(500))  // 500ms connection timeout\n    .readTimeout(Duration.ofSeconds(5))      // 5s read timeout\n    .build();\n\n// This will timeout quickly if the server is slow\ntry {\n    client.get("https://slow-api.example.com/data").execute();\n} catch (ApiException e) {\n    System.out.println("Request timed out: " + e.getMessage());\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"logging-support",children:"Logging Support"}),"\n",(0,i.jsx)(n.p,{children:"Enable comprehensive logging for debugging and monitoring."}),"\n",(0,i.jsx)(n.h3,{id:"basic-logging",children:"Basic Logging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'ApiClient client = new ApiClient.Builder()\n    .enableLogging()  // Enables console logging\n    .build();\n\n// All requests and responses will be logged to console\nclient.get("https://api.example.com/data").execute();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"custom-logging",children:"Custom Logging"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"import java.util.function.Consumer;\n\n// Custom logger function\nConsumer<String> customLogger = message -> {\n    // Log to your preferred logging framework\n    logger.info(message);\n};\n\nApiClient client = new ApiClient.Builder()\n    .addRequestInterceptor(RequestInterceptor.logging(customLogger))\n    .addResponseInterceptor(ResponseInterceptor.logging(customLogger))\n    .build();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"slf4j-integration",children:"SLF4J Integration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"import org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nLogger logger = LoggerFactory.getLogger(MyClass.class);\n\nApiClient client = new ApiClient.Builder()\n    .addRequestInterceptor(RequestInterceptor.logging(logger::info))\n    .addResponseInterceptor(ResponseInterceptor.logging(logger::info))\n    .build();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"migration-from-v10x",children:"Migration from v1.0.x"}),"\n",(0,i.jsx)(n.p,{children:"MochaJSON v1.1.0 is 100% backward compatible with v1.0.x."}),"\n",(0,i.jsx)(n.h3,{id:"existing-code-continues-to-work",children:"Existing Code Continues to Work"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// This code from v1.0.x works exactly the same in v1.1.0\nApiResponse response = Api.get("https://api.example.com/data")\n    .query("page", 1)\n    .execute();\n\nMap<String, Object> data = response.toMap();\n'})}),"\n",(0,i.jsx)(n.h3,{id:"optional-migration-to-apiclient",children:"Optional Migration to ApiClient"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Old way (still works)\nApiResponse response = Api.get("https://api.example.com/data")\n    .query("page", 1)\n    .execute();\n\n// New way (optional, for advanced features)\nApiClient client = new ApiClient.Builder()\n    .connectTimeout(Duration.ofSeconds(10))\n    .enableLogging()\n    .build();\n\nApiResponse response = client.get("https://api.example.com/data")\n    .query("page", 1)\n    .execute();\n'})}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"use-apiclient-for-production",children:"Use ApiClient for Production"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Recommended for production applications\nApiClient client = new ApiClient.Builder()\n    .connectTimeout(Duration.ofSeconds(10))\n    .readTimeout(Duration.ofSeconds(30))\n    .enableLogging()\n    .addRequestInterceptor(RequestInterceptor.bearerAuth(() -> getToken()))\n    .addResponseInterceptor(ResponseInterceptor.throwOnError())\n    .build();\n"})}),"\n",(0,i.jsx)(n.h3,{id:"handle-async-operations-properly",children:"Handle Async Operations Properly"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'// Good: Proper exception handling\nCompletableFuture<ApiResponse> future = client.get("https://api.example.com/data")\n    .executeAsync();\n\nfuture.thenAccept(response -> {\n    // Handle success\n}).exceptionally(throwable -> {\n    // Handle error\n    logger.error("Request failed", throwable);\n    return null;\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"use-interceptors-for-cross-cutting-concerns",children:"Use Interceptors for Cross-Cutting Concerns"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"// Authentication for all requests\nApiClient authenticatedClient = new ApiClient.Builder()\n    .addRequestInterceptor(RequestInterceptor.bearerAuth(() -> getToken()))\n    .build();\n\n// Logging for debugging\nApiClient debugClient = new ApiClient.Builder()\n    .enableLogging()\n    .build();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"virtual-threads",children:"Virtual Threads"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Virtual threads provide better performance for I/O-bound operations"}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"executeAsync()"})," for concurrent requests"]}),"\n",(0,i.jsx)(n.li,{children:"Virtual threads are automatically used on Java 21+"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"MochaJSON uses Java's built-in HTTP client connection pooling"}),"\n",(0,i.jsx)(n.li,{children:"Configure timeouts appropriately for your use case"}),"\n",(0,i.jsx)(n.li,{children:"Consider connection limits for high-traffic applications"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"memory-usage",children:"Memory Usage"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"MochaJSON has a minimal memory footprint"}),"\n",(0,i.jsx)(n.li,{children:"Response bodies are streamed when possible"}),"\n",(0,i.jsx)(n.li,{children:"Use appropriate timeout values to prevent memory leaks"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var r=t(6540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);