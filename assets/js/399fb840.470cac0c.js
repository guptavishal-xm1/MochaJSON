"use strict";(globalThis.webpackChunkmochaapi_client_docs=globalThis.webpackChunkmochaapi_client_docs||[]).push([[4],{43:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"best-practices/common-mistakes","title":"Common Mistakes","description":"Avoid these common mistakes when using MochaJSON. Learn about error handling, async operations, connection management, and security pitfalls.","source":"@site/docs/best-practices/common-mistakes.md","sourceDirName":"best-practices","slug":"/best-practices/common-mistakes","permalink":"/MochaJSON/best-practices/common-mistakes","draft":false,"unlisted":false,"editUrl":"https://github.com/guptavishal-xm1/MochaJSON/tree/main/docs/docs/best-practices/common-mistakes.md","tags":[],"version":"current","frontMatter":{"title":"Common Mistakes","description":"Avoid these common mistakes when using MochaJSON. Learn about error handling, async operations, connection management, and security pitfalls.","keywords":["MochaJSON mistakes","HTTP client errors","Java HTTP mistakes","Kotlin HTTP mistakes","debugging MochaJSON"]},"sidebar":"tutorialSidebar","previous":{"title":"Production Checklist","permalink":"/MochaJSON/best-practices/production-checklist"},"next":{"title":"Performance Tips","permalink":"/MochaJSON/best-practices/performance-tips"}}');var t=i(4848),r=i(8453);const a={title:"Common Mistakes",description:"Avoid these common mistakes when using MochaJSON. Learn about error handling, async operations, connection management, and security pitfalls.",keywords:["MochaJSON mistakes","HTTP client errors","Java HTTP mistakes","Kotlin HTTP mistakes","debugging MochaJSON"]},o="Common Mistakes",l={},c=[{value:"\u274c Error Handling Mistakes",id:"-error-handling-mistakes",level:2},{value:"Mistake 1: Not Handling Exceptions",id:"mistake-1-not-handling-exceptions",level:3},{value:"Mistake 2: Not Managing Resources Properly",id:"mistake-2-not-managing-resources-properly",level:3},{value:"Mistake 3: Swallowing Exceptions",id:"mistake-3-swallowing-exceptions",level:3},{value:"Mistake 3: Not Checking Response Status",id:"mistake-3-not-checking-response-status",level:3},{value:"\u274c Async Operation Mistakes",id:"-async-operation-mistakes",level:2},{value:"Mistake 4: Blocking Async Operations",id:"mistake-4-blocking-async-operations",level:3},{value:"Mistake 5: Not Handling Async Exceptions",id:"mistake-5-not-handling-async-exceptions",level:3},{value:"\u274c Connection Management Mistakes",id:"-connection-management-mistakes",level:2},{value:"Mistake 6: Creating New Clients for Each Request",id:"mistake-6-creating-new-clients-for-each-request",level:3},{value:"Mistake 7: Not Configuring Timeouts",id:"mistake-7-not-configuring-timeouts",level:3},{value:"Mistake 8: Not Enabling Connection Pooling",id:"mistake-8-not-enabling-connection-pooling",level:3},{value:"\u274c Security Mistakes",id:"-security-mistakes",level:2},{value:"Mistake 9: Hardcoding Secrets",id:"mistake-9-hardcoding-secrets",level:3},{value:"Mistake 10: Not Validating Input",id:"mistake-10-not-validating-input",level:3},{value:"Mistake 11: Using HTTP in Production",id:"mistake-11-using-http-in-production",level:3},{value:"\u274c Performance Mistakes",id:"-performance-mistakes",level:2},{value:"Mistake 12: Not Using Caching",id:"mistake-12-not-using-caching",level:3},{value:"Mistake 13: Synchronous Operations in Loops",id:"mistake-13-synchronous-operations-in-loops",level:3},{value:"\u274c Configuration Mistakes",id:"-configuration-mistakes",level:2},{value:"Mistake 14: Not Using Retry Logic",id:"mistake-14-not-using-retry-logic",level:3},{value:"Mistake 15: Not Using Circuit Breaker",id:"mistake-15-not-using-circuit-breaker",level:3},{value:"\u274c Testing Mistakes",id:"-testing-mistakes",level:2},{value:"Mistake 16: Not Testing Error Scenarios",id:"mistake-16-not-testing-error-scenarios",level:3},{value:"Mistake 17: Not Mocking External Dependencies",id:"mistake-17-not-mocking-external-dependencies",level:3},{value:"\u274c Logging Mistakes",id:"-logging-mistakes",level:2},{value:"Mistake 18: Logging Sensitive Information",id:"mistake-18-logging-sensitive-information",level:3},{value:"Mistake 19: Too Verbose Logging in Production",id:"mistake-19-too-verbose-logging-in-production",level:3},{value:"\u274c Resource Management Mistakes",id:"-resource-management-mistakes",level:2},{value:"Mistake 20: Not Cleaning Up Resources",id:"mistake-20-not-cleaning-up-resources",level:3},{value:"How to Avoid These Mistakes",id:"how-to-avoid-these-mistakes",level:2},{value:"Next Steps",id:"next-steps",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"common-mistakes",children:"Common Mistakes"})}),"\n",(0,t.jsx)(n.p,{children:"Avoid these common pitfalls when using MochaJSON. Learn from others' mistakes and build more reliable applications."}),"\n",(0,t.jsx)(n.h2,{id:"-error-handling-mistakes",children:"\u274c Error Handling Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-1-not-handling-exceptions",children:"Mistake 1: Not Handling Exceptions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Silent failures\npublic User getUser(String id) {\n    Map<String, Object> response = Api.get("/api/users/" + id)\n        .execute()\n        .toMap();\n    return new User(response); // Could throw NullPointerException\n}\n\n// \u2705 GOOD: Proper error handling\npublic User getUser(String id) {\n    try {\n        Map<String, Object> response = Api.get("/api/users/" + id)\n            .execute()\n            .toMap();\n        return new User(response);\n    } catch (ApiException e) {\n        logger.error("Failed to get user: " + id, e);\n        throw new UserServiceException("User service unavailable", e);\n    } catch (JsonException e) {\n        logger.error("Invalid response format for user: " + id, e);\n        throw new DataProcessingException("Invalid user data", e);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-2-not-managing-resources-properly",children:"Mistake 2: Not Managing Resources Properly"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c BAD: Memory leak - InputStream not closed\npublic byte[] downloadFile(String url) {\n    InputStream stream = client.get(url).downloadStream();\n    return stream.readAllBytes(); // Stream never closed!\n}\n\n// \u2705 GOOD: Always use try-with-resources\npublic byte[] downloadFile(String url) {\n    try (ManagedInputStream stream = client.get(url).downloadStream()) {\n        return stream.readAllBytes();\n    } // Stream is automatically closed\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-3-swallowing-exceptions",children:"Mistake 3: Swallowing Exceptions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Swallowing exceptions\npublic User getUser(String id) {\n    try {\n        return Api.get("/api/users/" + id)\n            .execute()\n            .to(User.class);\n    } catch (Exception e) {\n        // Silent failure - very bad!\n        return null;\n    }\n}\n\n// \u2705 GOOD: Proper exception propagation\npublic User getUser(String id) {\n    try {\n        return Api.get("/api/users/" + id)\n            .execute()\n            .to(User.class);\n    } catch (ApiException e) {\n        if (e.getStatusCode() == 404) {\n            throw new UserNotFoundException("User not found: " + id);\n        }\n        throw new UserServiceException("Failed to retrieve user", e);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-3-not-checking-response-status",children:"Mistake 3: Not Checking Response Status"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Not checking response status\npublic String getData(String url) {\n    ApiResponse response = Api.get(url).execute();\n    return response.body(); // Could be error response body\n}\n\n// \u2705 GOOD: Check response status\npublic String getData(String url) {\n    ApiResponse response = Api.get(url).execute();\n    \n    if (response.isError()) {\n        throw new ApiException("API returned error: " + response.code());\n    }\n    \n    return response.body();\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"-async-operation-mistakes",children:"\u274c Async Operation Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-4-blocking-async-operations",children:"Mistake 4: Blocking Async Operations"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Blocking async operations\npublic List<User> getAllUsers() {\n    List<CompletableFuture<User>> futures = new ArrayList<>();\n    \n    for (String id : userIds) {\n        CompletableFuture<User> future = client.get("/api/users/" + id)\n            .executeAsync()\n            .thenApply(response -> response.to(User.class));\n        futures.add(future);\n    }\n    \n    // \u274c This blocks the thread!\n    return futures.stream()\n        .map(CompletableFuture::join)\n        .collect(Collectors.toList());\n}\n\n// \u2705 GOOD: Proper async handling\npublic CompletableFuture<List<User>> getAllUsersAsync() {\n    List<CompletableFuture<User>> futures = userIds.stream()\n        .map(id -> client.get("/api/users/" + id)\n            .executeAsync()\n            .thenApply(response -> response.to(User.class)))\n        .collect(Collectors.toList());\n    \n    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n        .thenApply(v -> futures.stream()\n            .map(CompletableFuture::join)\n            .collect(Collectors.toList()));\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-5-not-handling-async-exceptions",children:"Mistake 5: Not Handling Async Exceptions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Unhandled async exceptions\npublic void processUsers(List<String> userIds) {\n    userIds.forEach(id -> \n        client.get("/api/users/" + id)\n            .executeAsync()\n            .thenAccept(response -> {\n                // \u274c Exception here will be swallowed!\n                User user = response.to(User.class);\n                processUser(user);\n            })\n    );\n}\n\n// \u2705 GOOD: Handle async exceptions\npublic void processUsers(List<String> userIds) {\n    userIds.forEach(id -> \n        client.get("/api/users/" + id)\n            .executeAsync()\n            .thenAccept(response -> {\n                try {\n                    User user = response.to(User.class);\n                    processUser(user);\n                } catch (Exception e) {\n                    logger.error("Failed to process user: " + id, e);\n                }\n            })\n            .exceptionally(throwable -> {\n                logger.error("Failed to get user: " + id, throwable);\n                return null;\n            })\n    );\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"-connection-management-mistakes",children:"\u274c Connection Management Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-6-creating-new-clients-for-each-request",children:"Mistake 6: Creating New Clients for Each Request"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Creating new client for each request\npublic User getUser(String id) {\n    ApiClient client = new ApiClient.Builder().build(); // \u274c New client every time!\n    return client.get("/api/users/" + id)\n        .execute()\n        .to(User.class);\n}\n\n// \u2705 GOOD: Reuse client instance\npublic class UserService {\n    private final ApiClient client = new ApiClient.Builder()\n        .enableConnectionPooling()\n        .build();\n    \n    public User getUser(String id) {\n        return client.get("/api/users/" + id)\n            .execute()\n            .to(User.class);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-7-not-configuring-timeouts",children:"Mistake 7: Not Configuring Timeouts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c BAD: Using default timeouts in production\nApiClient client = new ApiClient.Builder().build(); // Default timeouts might be too long\n\n// \u2705 GOOD: Configure appropriate timeouts\nApiClient client = new ApiClient.Builder()\n    .connectTimeout(Duration.ofSeconds(10))    // Fast connection timeout\n    .readTimeout(Duration.ofSeconds(30))       // Reasonable read timeout\n    .build();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-8-not-enabling-connection-pooling",children:"Mistake 8: Not Enabling Connection Pooling"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c BAD: No connection pooling\nApiClient client = new ApiClient.Builder().build();\n\n// \u2705 GOOD: Enable connection pooling for better performance\nApiClient client = new ApiClient.Builder()\n    .enableConnectionPooling()\n    .build();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-security-mistakes",children:"\u274c Security Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-9-hardcoding-secrets",children:"Mistake 9: Hardcoding Secrets"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Hardcoded API key\nApiClient client = new ApiClient.Builder()\n    .addRequestInterceptor(RequestInterceptor.bearerAuth(() -> "secret-api-key"))\n    .build();\n\n// \u2705 GOOD: Use environment variables or secure storage\n@Value("${api.key}")\nprivate String apiKey;\n\nApiClient client = new ApiClient.Builder()\n    .addRequestInterceptor(RequestInterceptor.bearerAuth(() -> apiKey))\n    .build();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-10-not-validating-input",children:"Mistake 10: Not Validating Input"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: No input validation\npublic User getUser(String id) {\n    return client.get("/api/users/" + id)  // \u274c Could be malicious input\n        .execute()\n        .to(User.class);\n}\n\n// \u2705 GOOD: Validate and sanitize input\npublic User getUser(String id) {\n    if (id == null || id.trim().isEmpty()) {\n        throw new IllegalArgumentException("User ID cannot be null or empty");\n    }\n    \n    // Sanitize the ID\n    String sanitizedId = id.trim().replaceAll("[^a-zA-Z0-9-_]", "");\n    \n    return client.get("/api/users/" + sanitizedId)\n        .execute()\n        .to(User.class);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-11-using-http-in-production",children:"Mistake 11: Using HTTP in Production"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: HTTP in production\nApiClient client = new ApiClient.Builder()\n    .baseUrl("http://api.example.com")  // \u274c Not secure\n    .build();\n\n// \u2705 GOOD: Always use HTTPS in production\nApiClient client = new ApiClient.Builder()\n    .baseUrl("https://api.example.com")  // \u2705 Secure\n    .build();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"-performance-mistakes",children:"\u274c Performance Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-12-not-using-caching",children:"Mistake 12: Not Using Caching"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: No caching for frequently accessed data\npublic User getUser(String id) {\n    return client.get("/api/users/" + id)  // \u274c Hits API every time\n        .execute()\n        .to(User.class);\n}\n\n// \u2705 GOOD: Enable caching for better performance\nApiClient client = new ApiClient.Builder()\n    .enableCaching()\n    .build();\n\npublic User getUser(String id) {\n    return client.get("/api/users/" + id)  // \u2705 Uses cache when appropriate\n        .execute()\n        .to(User.class);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-13-synchronous-operations-in-loops",children:"Mistake 13: Synchronous Operations in Loops"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Synchronous operations in loop\npublic List<User> getUsers(List<String> ids) {\n    return ids.stream()\n        .map(id -> client.get("/api/users/" + id).execute().to(User.class))  // \u274c Sequential\n        .collect(Collectors.toList());\n}\n\n// \u2705 GOOD: Parallel async operations\npublic CompletableFuture<List<User>> getUsersAsync(List<String> ids) {\n    List<CompletableFuture<User>> futures = ids.stream()\n        .map(id -> client.get("/api/users/" + id)\n            .executeAsync()\n            .thenApply(response -> response.to(User.class)))\n        .collect(Collectors.toList());\n    \n    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n        .thenApply(v -> futures.stream()\n            .map(CompletableFuture::join)\n            .collect(Collectors.toList()));\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"-configuration-mistakes",children:"\u274c Configuration Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-14-not-using-retry-logic",children:"Mistake 14: Not Using Retry Logic"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c BAD: No retry for transient failures\nApiClient client = new ApiClient.Builder().build();\n\n// \u2705 GOOD: Enable retry for resilience\nApiClient client = new ApiClient.Builder()\n    .enableRetryPolicy()\n    .build();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-15-not-using-circuit-breaker",children:"Mistake 15: Not Using Circuit Breaker"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c BAD: No circuit breaker protection\nApiClient client = new ApiClient.Builder().build();\n\n// \u2705 GOOD: Enable circuit breaker for fault tolerance\nApiClient client = new ApiClient.Builder()\n    .enableCircuitBreaker()\n    .build();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-testing-mistakes",children:"\u274c Testing Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-16-not-testing-error-scenarios",children:"Mistake 16: Not Testing Error Scenarios"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Only testing happy path\n@Test\npublic void testGetUser() {\n    User user = userService.getUser("123");\n    assertThat(user).isNotNull();\n}\n\n// \u2705 GOOD: Test error scenarios too\n@Test\npublic void testGetUser_Success() {\n    User user = userService.getUser("123");\n    assertThat(user).isNotNull();\n}\n\n@Test\npublic void testGetUser_NotFound() {\n    assertThatThrownBy(() -> userService.getUser("nonexistent"))\n        .isInstanceOf(UserNotFoundException.class);\n}\n\n@Test\npublic void testGetUser_ServerError() {\n    assertThatThrownBy(() -> userService.getUser("server-error"))\n        .isInstanceOf(UserServiceException.class);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-17-not-mocking-external-dependencies",children:"Mistake 17: Not Mocking External Dependencies"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Tests depend on external API\n@Test\npublic void testGetUser() {\n    // \u274c This will fail if external API is down\n    User user = userService.getUser("123");\n    assertThat(user).isNotNull();\n}\n\n// \u2705 GOOD: Mock external dependencies\n@Test\npublic void testGetUser() {\n    // Mock the API response\n    when(mockClient.get("/api/users/123"))\n        .thenReturn(mockResponse);\n    when(mockResponse.to(User.class))\n        .thenReturn(new User("123", "John Doe"));\n    \n    User user = userService.getUser("123");\n    assertThat(user.getName()).isEqualTo("John Doe");\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"-logging-mistakes",children:"\u274c Logging Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-18-logging-sensitive-information",children:"Mistake 18: Logging Sensitive Information"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Logging sensitive data\npublic User authenticate(String username, String password) {\n    logger.info("Authenticating user: {} with password: {}", username, password);  // \u274c Logs password!\n    \n    return client.post("/api/auth")\n        .body(Map.of("username", username, "password", password))\n        .execute()\n        .to(User.class);\n}\n\n// \u2705 GOOD: Don\'t log sensitive information\npublic User authenticate(String username, String password) {\n    logger.info("Authenticating user: {}", username);  // \u2705 Safe logging\n    \n    return client.post("/api/auth")\n        .body(Map.of("username", username, "password", password))\n        .execute()\n        .to(User.class);\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"mistake-19-too-verbose-logging-in-production",children:"Mistake 19: Too Verbose Logging in Production"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// \u274c BAD: Debug logging in production\nApiClient client = new ApiClient.Builder()\n    .enableLogging()  // \u274c Might be too verbose\n    .build();\n\n// \u2705 GOOD: Appropriate logging level\nApiClient client = new ApiClient.Builder()\n    .enableLogging()  // \u2705 Configure appropriate level in production\n    .build();\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-resource-management-mistakes",children:"\u274c Resource Management Mistakes"}),"\n",(0,t.jsx)(n.h3,{id:"mistake-20-not-cleaning-up-resources",children:"Mistake 20: Not Cleaning Up Resources"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// \u274c BAD: Not properly managing resources\npublic void uploadFile(File file) {\n    client.post("/api/upload")\n        .multipart()\n        .addFile("file", file)\n        .execute();  // \u274c Large file might not be cleaned up properly\n}\n\n// \u2705 GOOD: Proper resource management\npublic void uploadFile(File file) {\n    try (InputStream inputStream = new FileInputStream(file)) {\n        client.post("/api/upload")\n            .multipart()\n            .addFile("file", inputStream, file.getName())\n            .execute();\n    } catch (IOException e) {\n        throw new FileProcessingException("Failed to upload file", e);\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"how-to-avoid-these-mistakes",children:"How to Avoid These Mistakes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Always handle exceptions"})," - Don't let them be swallowed or ignored"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use proper async patterns"})," - Don't block async operations unnecessarily"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reuse client instances"})," - Don't create new clients for each request"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Configure timeouts"})," - Set appropriate timeouts for your use case"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enable production features"})," - Use connection pooling, retry, circuit breaker"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validate input"})," - Always validate and sanitize user input"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use HTTPS"})," - Never use HTTP in production"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Enable caching"})," - Use caching for frequently accessed data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test error scenarios"})," - Don't just test the happy path"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Log appropriately"})," - Don't log sensitive information or be too verbose"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/MochaJSON/best-practices/production-checklist",children:"Production Checklist"})})," - Ensure your deployment is production-ready"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.a,{href:"/MochaJSON/best-practices/performance-tips",children:"Performance Tips"})})," - Optimize your HTTP client performance"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>o});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);